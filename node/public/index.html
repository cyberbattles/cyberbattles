<!doctype html>
<html>
  <head>
    <title>Docker Terminal Control</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script
      type="module"
      src="https://unpkg.com/pcap-element/dist/pcap-element.esm.min.js"
    ></script>
    <style>
      body {
        font-family: sans-serif;
        background-color: #1e1e1e;
        color: #f0f0f0;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .container {
        max-width: 1200px;
        width: 100%;
      }
      .header-container {
        display: flex;
        align-items: center;
        gap: 15px;
        width: 100%;
        margin-bottom: -10px;
      }
      #health-status-container {
        position: relative;
        display: inline-block;
      }
      #health-status-indicator {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: #888;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }
      #health-status-indicator.healthy {
        background-color: #28a745;
      }
      #health-status-indicator.unhealthy {
        background-color: #dc3545;
      }
      #health-tooltip {
        visibility: hidden;
        width: 280px;
        background-color: #111;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 10px;
        position: absolute;
        z-index: 1;
        top: 125%;
        left: 50%;
        margin-left: -140px;
        opacity: 0;
        transition: opacity 0.3s;
        border: 1px solid #555;
        font-family: monospace;
        font-size: 12px;
        white-space: pre-wrap;
        pointer-events: none;
      }
      #health-status-container:hover #health-tooltip {
        visibility: visible;
        opacity: 1;
      }
      fieldset {
        border: 1px solid #555;
        border-radius: 5px;
        margin-bottom: 20px;
        padding: 15px;
      }
      legend {
        color: #00aaff;
        font-weight: bold;
        padding: 0 10px;
      }
      .controls {
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 10px;
      }
      input[type='text'],
      input[type='number'],
      select {
        background-color: #333;
        color: #f0f0f0;
        border: 1px solid #555;
        padding: 8px;
        border-radius: 3px;
      }
      button {
        background-color: #0077cc;
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 3px;
        cursor: pointer;
      }
      button:hover {
        background-color: #005fa3;
      }
      #cleanup-session-btn:hover {
        background-color: #c9302c;
      }
      #terminal-container {
        padding: 10px;
      }
      #terminal {
        border: 1px solid #555;
      }
      #session-info {
        margin-top: 15px;
        padding: 10px;
        background-color: #2a2a2a;
        border-radius: 4px;
        border: 1px solid #444;
      }
      #session-info h3 {
        margin-top: 0;
        color: #00aaff;
      }
      #session-info ul {
        list-style-type: none;
        padding-left: 0;
        margin: 0;
      }
      #session-info li {
        background-color: #333;
        padding: 5px 8px;
        border-radius: 3px;
        margin-bottom: 5px;
        font-family: monospace;
      }
      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .modal {
        background-color: #2a2a2a;
        padding: 25px;
        border-radius: 8px;
        border: 1px solid #555;
        width: 80%;
        max-width: 900px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      }
      .modal h2 {
        margin-top: 0;
        color: #00aaff;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }
      .modal-buttons {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 15px;
        border-top: 1px solid #444;
        padding-top: 15px;
        margin-top: 10px;
      }
      .pcap-controls {
        margin-right: auto;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .config-content {
        display: flex;
        gap: 20px;
        margin: 20px 0;
      }
      .config-text-container {
        flex: 1;
      }
      .config-info-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      #config-text,
      #tutorial-text {
        background-color: #1e1e1e;
        color: #f0f0f0;
        border: 1px solid #555;
        padding: 10px;
        border-radius: 4px;
        max-height: 400px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: monospace;
      }
      #tutorial-text {
        color: #a6e22e;
      }
      .config-qr-container {
        text-align: center;
      }
      .config-qr-container img {
        max-width: 200px;
        height: auto;
        background-color: white;
        padding: 5px;
        border-radius: 4px;
      }
      #pcap-modal {
        width: 95%;
        height: 90%;
        max-width: none;
        display: flex;
        flex-direction: column;
      }
      #pcap-element-container {
        flex-grow: 1;
        background-color: #fff;
        border-radius: 4px;
        overflow-y: auto;
        color: #333;
      }

      /* Tab container styles */
      .tabs {
        overflow: hidden;
        border-bottom: 1px solid #555;
        margin-bottom: 20px;
        width: 100%;
      }
      .tab-button {
        background-color: #333;
        border: 1px solid #555;
        border-bottom: none;
        border-radius: 5px 5px 0 0;
        cursor: pointer;
        padding: 10px 20px;
        color: #f0f0f0;
        font-size: 16px;
        margin-right: 5px;
        outline: none;
      }
      .tab-button:hover {
        background-color: #444;
      }
      .tab-button.active {
        background-color: #1e1e1e;
        border-bottom: 1px solid #1e1e1e;
        color: #00aaff;
      }
      .tab-content {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header-container">
        <h1>Docker Web Terminal Control Panel</h1>
        <div id="health-status-container">
          <div id="health-status-indicator"></div>
          <div id="health-tooltip">Checking status...</div>
        </div>
      </div>

      <div class="tabs">
        <button class="tab-button active" onclick="openTab(event, 'Admin')">
          Admin
        </button>
        <button class="tab-button" onclick="openTab(event, 'Player')">
          Player
        </button>
      </div>

      <div id="Admin" class="tab-content" style="display: block">
        <fieldset>
          <legend>Session Management</legend>
          <div class="controls">
            <label for="admin-jwt">Admin JWT:</label>
            <input
              type="text"
              id="admin-jwt"
              name="admin-jwt"
              placeholder="Paste Admin JWT for session actions"
              size="60"
            />
          </div>
          <hr style="border-color: #444; margin: 15px 0" />
          <div class="controls">
            <label for="scenario-id">Scenario ID:</label>
            <input
              type="text"
              id="scenario-id"
              name="scenario-id"
              value="8429abfca004aed7"
              size="25"
            />
            <label for="num-teams">Num Teams:</label>
            <input
              type="number"
              id="num-teams"
              name="num-teams"
              value="2"
              min="1"
            />
            <label for="num-members">Members/Team:</label>
            <input
              type="number"
              id="num-members"
              name="num-members"
              value="1"
              min="1"
            />
            <button id="create-session-btn">Create Session</button>
          </div>
          <div class="controls">
            <label for="session-id">Session ID:</label>
            <input
              type="text"
              id="session-id"
              name="session-id"
              placeholder="Autofilled after creation"
              readonly
            />
            <button id="start-session-btn">Start Session</button>
            <button
              id="cleanup-session-btn"
              style="display: none; background-color: #d9534f"
            >
              Cleanup Session
            </button>
          </div>
          <div id="session-info" style="display: none">
            <h3>Created Team IDs</h3>
            <ul id="team-id-list"></ul>
          </div>
        </fieldset>

        <fieldset>
          <legend>Terminal Connection</legend>
          <div class="controls">
            <label for="teamId">Team ID:</label>
            <select id="teamId" name="teamId">
              <option>-- Start a session first --</option>
            </select>
            <label for="userId">User ID:</label>
            <select id="userId" name="userId">
              <option>-- Select a team first --</option>
            </select>
            <label for="jwt-token">JWT:</label>
            <input
              type="text"
              id="jwt-token"
              name="jwt-token"
              placeholder="Autofills from Admin JWT"
              size="60"
            />
            <button id="connect-btn">Connect to Terminal</button>
            <button id="get-config-btn" style="display: none">
              Get Config
            </button>
            <button id="view-pcap-btn" style="display: none">View PCAP</button>
          </div>
        </fieldset>
      </div>

      <div id="Player" class="tab-content">
        <fieldset>
          <legend>Terminal Connection</legend>
          <div class="controls">
            <label for="player-session-id">Session ID:</label>
            <input
              type="text"
              id="player-session-id"
              placeholder="Enter Session ID"
            />
            <label for="player-team-id">Team ID:</label>
            <input
              type="text"
              id="player-team-id"
              placeholder="Enter Team ID"
            />
            <label for="player-user-id">User ID:</label>
            <input
              type="text"
              id="player-user-id"
              placeholder="Enter User ID"
            />
          </div>
          <div class="controls">
            <label for="player-jwt-token">JWT:</label>
            <input
              type="text"
              id="player-jwt-token"
              placeholder="Paste your player JWT"
              size="60"
            />
            <button id="player-connect-btn">Connect to Terminal</button>
            <button id="player-get-config-btn">Get Config</button>
            <button id="player-view-pcap-btn">View PCAP</button>
          </div>
        </fieldset>
      </div>

      <div id="terminal-container">
        <div id="terminal"></div>
      </div>
    </div>

    <div id="config-overlay" class="overlay">
      <div id="config-modal" class="modal">
        <h2>WireGuard Configuration & Access</h2>
        <div class="config-content">
          <div class="config-text-container">
            <pre id="config-text"></pre>
          </div>
          <div class="config-info-container">
            <div class="config-qr-container">
              <img id="config-qr-code" src="" alt="WireGuard QR Code" />
            </div>
            <pre id="tutorial-text"></pre>
          </div>
        </div>
        <div class="modal-buttons">
          <button id="download-config-btn">Download .conf</button>
          <button id="close-config-overlay-btn">Close</button>
        </div>
      </div>
    </div>

    <div id="pcap-overlay" class="overlay">
      <div id="pcap-modal" class="modal">
        <h2>Packet Capture Analysis</h2>
        <div id="pcap-element-container">
          <pcap-element
            lang="en-us"
            showFullscreenBtn="true"
            sortOrder="desc"
          ></pcap-element>
        </div>
        <div class="modal-buttons">
          <div class="pcap-controls">
            <button id="refresh-pcap-btn">Refresh</button>
            <label>
              <input type="checkbox" id="pause-pcap-refresh" />
              Pause Auto-Refresh
            </label>
          </div>
          <button id="close-pcap-overlay-btn">Close</button>
        </div>
      </div>
    </div>

    <script>
      // --- TAB SWITCHING LOGIC ---
      function openTab(evt, tabName) {
        // Get all elements with class="tab-content" and hide them
        const tabcontent = document.getElementsByClassName('tab-content');
        for (let i = 0; i < tabcontent.length; i++) {
          tabcontent[i].style.display = 'none';
        }

        // Get all elements with class="tab-button" and remove the class "active"
        const tablinks = document.getElementsByClassName('tab-button');
        for (let i = 0; i < tablinks.length; i++) {
          tablinks[i].classList.remove('active');
        }

        // Show the current tab, and add an "active" class to the button that opened the tab
        document.getElementById(tabName).style.display = 'block';
        evt.currentTarget.classList.add('active');
      }

      const term = new Terminal({
        cursorBlink: true,
        rows: 30,
        cols: 120,
        theme: {
          background: '#1e1e1e',
          foreground: '#f0f0f0',
        },
      });
      term.open(document.getElementById('terminal'));
      term.write('Welcome! Use the controls above to manage sessions.\r\n');

      let ws;
      let sessionTeams = [];
      let createdTeamIds = [];

      async function postData(url = '', data = {}) {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data),
        });
        const responseData = await response.json().catch(() => ({}));
        return {
          ok: response.ok,
          status: response.status,
          data: responseData,
        };
      }

      // --- ADMIN TAB EVENT LISTENERS ---
      document.getElementById('admin-jwt').addEventListener('input', event => {
        document.getElementById('jwt-token').value = event.target.value;
      });

      document
        .getElementById('create-session-btn')
        .addEventListener('click', async () => {
          term.write('\r\nAttempting to create a new session...\r\n');
          document.getElementById('get-config-btn').style.display = 'none';
          document.getElementById('view-pcap-btn').style.display = 'none';
          document.getElementById('cleanup-session-btn').style.display = 'none';
          const token = document.getElementById('admin-jwt').value;
          if (!token) {
            term.write(
              '\r\nERROR: Admin JWT is required to create a session.\r\n',
            );
            return;
          }

          const scenarioId = document.getElementById('scenario-id').value;
          const numTeams = parseInt(document.getElementById('num-teams').value);
          const numMembersPerTeam = parseInt(
            document.getElementById('num-members').value,
          );

          const response = await postData('/api/session', {
            scenarioId,
            numTeams,
            numMembersPerTeam,
            token,
          });

          if (response.ok && response.data.result) {
            const {sessionId, teamIds} = response.data.result;
            term.write(
              `SUCCESS: Session ${sessionId} created with ${teamIds.length} teams.\r\n`,
            );

            document.getElementById('session-id').value = sessionId;
            createdTeamIds = teamIds;

            const teamList = document.getElementById('team-id-list');
            const sessionInfoDiv = document.getElementById('session-info');
            teamList.innerHTML = '';
            teamIds.forEach(id => {
              const listItem = document.createElement('li');
              listItem.textContent = id;
              teamList.appendChild(listItem);
            });
            sessionInfoDiv.style.display = 'block';
            document.getElementById('cleanup-session-btn').style.display =
              'inline-block';
          } else {
            const errorMsg =
              response.data.result || `Status: ${response.status}`;
            term.write(
              `\r\nERROR: Failed to create session. Server says: ${errorMsg}\r\n`,
            );
          }
        });

      document
        .getElementById('start-session-btn')
        .addEventListener('click', async () => {
          const sessionId = document.getElementById('session-id').value;
          const token = document.getElementById('admin-jwt').value;
          if (!sessionId) {
            term.write('\r\nERROR: No Session ID found to start.\r\n');
            return;
          }
          if (!token) {
            term.write(
              '\r\nERROR: Admin JWT is required to start a session.\r\n',
            );
            return;
          }

          term.write(`\r\nAttempting to start session: ${sessionId}...\r\n`);
          const response = await postData('/api/start-session', {
            sessionId,
            token,
          });

          if (response.ok) {
            term.write(
              `SUCCESS: ${response.data.result} (Status: ${response.status}).\r\n`,
            );
            populateConnectionDropdowns(response.data.teamsAndMembers);
          } else {
            const errorMsg =
              response.data.result || `Status: ${response.status}`;
            term.write(
              `\r\nERROR: Failed to start session. Server says: ${errorMsg}\r\n`,
            );
          }
        });

      function populateConnectionDropdowns(teamsAndMembers) {
        if (!teamsAndMembers || createdTeamIds.length === 0) {
          term.write(
            '\r\nWARN: No team data received or session not created properly.\r\n',
          );
          return;
        }

        const teamSelect = document.getElementById('teamId');
        teamSelect.innerHTML = '';
        sessionTeams = [];

        const sortedTeamNames = Object.keys(teamsAndMembers).sort((a, b) =>
          a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'}),
        );

        sortedTeamNames.forEach((teamName, index) => {
          const teamId = createdTeamIds[index];
          if (teamId) {
            sessionTeams.push({
              name: teamName,
              id: teamId,
              users: teamsAndMembers[teamName],
            });

            const option = document.createElement('option');
            option.value = teamId;
            option.textContent = `${teamName} (${teamId})`;
            teamSelect.appendChild(option);
          }
        });

        teamSelect.addEventListener('change', updateUserDropdown);
        teamSelect.dispatchEvent(new Event('change'));

        document.getElementById('get-config-btn').style.display =
          'inline-block';
        document.getElementById('view-pcap-btn').style.display = 'inline-block';
      }

      function updateUserDropdown() {
        const teamSelect = document.getElementById('teamId');
        const userSelect = document.getElementById('userId');
        const selectedTeamId = teamSelect.value;
        userSelect.innerHTML = '';

        const selectedTeam = sessionTeams.find(t => t.id === selectedTeamId);

        if (selectedTeam && selectedTeam.users.length > 0) {
          selectedTeam.users.forEach(userId => {
            const option = document.createElement('option');
            option.value = userId;
            option.textContent = userId;
            userSelect.appendChild(option);
          });
        } else {
          const option = document.createElement('option');
          option.textContent = '-- No users in team --';
          userSelect.appendChild(option);
        }
      }

      document.getElementById('connect-btn').addEventListener('click', () => {
        if (ws && ws.readyState !== WebSocket.CLOSED) {
          ws.close();
        }
        term.reset();

        const teamId = document.getElementById('teamId').value;
        const userId = document.getElementById('userId').value;
        const token = document.getElementById('jwt-token').value;

        if (!teamId || !userId || !token) {
          term.write('Please select a Team, a User, and provide a JWT.\r\n');
          return;
        }

        const socketUrl = `ws://${window.location.host}/terminals/${teamId}/${userId}/${token}`;
        term.write(`Connecting to ${socketUrl}...\r\n`);

        ws = new WebSocket(socketUrl);

        ws.onopen = () => {
          term.write('Connection established! You have a shell.\r\n');
          term.focus();
        };

        ws.onmessage = async event => {
          const data =
            event.data instanceof Blob
              ? new Uint8Array(await event.data.arrayBuffer())
              : event.data;
          term.write(data);
        };

        ws.onclose = event => {
          term.write(`\r\nConnection closed. Code: ${event.code}\r\n`);
        };

        ws.onerror = error => {
          term.write('\r\nAn error occurred with the WebSocket.\r\n');
          console.error('WebSocket Error:', error);
        };
      });

      term.onData(data => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(data);
        }
      });

      const configOverlay = document.getElementById('config-overlay');
      document
        .getElementById('get-config-btn')
        .addEventListener('click', async () => {
          const sessionId = document.getElementById('session-id').value;
          const teamId = document.getElementById('teamId').value;
          const userId = document.getElementById('userId').value;
          const token = document.getElementById('jwt-token').value;

          if (!sessionId || !teamId || !userId || !token) {
            term.write(
              '\r\nERROR: Session, Team, User, and JWT must be present.\r\n',
            );
            return;
          }

          term.write(`\r\nFetching config for user ${userId}...\r\n`);

          try {
            const response = await fetch(
              `/api/config/${sessionId}/${teamId}/${userId}/${token}`,
            );
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`,
              );
            }
            const data = await response.json();

            if (data.config && data.qrCode && data.username && data.ipAddress) {
              document.getElementById('config-text').textContent = data.config;
              document.getElementById('config-qr-code').src =
                `data:image/png;base64,${data.qrCode}`;

              const tutorial = `# Install wireguard if you haven't already
sudo wg-quick up ~/Downloads/wg1.conf
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${data.username}@${data.ipAddress}`;
              document.getElementById('tutorial-text').textContent = tutorial;

              configOverlay.style.display = 'flex';
            } else {
              term.write('\r\nERROR: Incomplete config data received.\r\n');
            }
          } catch (error) {
            term.write(
              `\r\nERROR: Failed to fetch config. ${error.message}\r\n`,
            );
          }
        });

      const pcapOverlay = document.getElementById('pcap-overlay');
      const pcapElement = document.querySelector('pcap-element');
      const pausePcapRefreshCheckbox =
        document.getElementById('pause-pcap-refresh');
      let pcapBlobUrl = null;
      let pcapRefreshInterval = null;

      async function fetchPcapData(teamId, token) {
        if (!teamId || !token) {
          term.write(
            '\r\nERROR: Team and JWT must be present to view PCAP.\r\n',
          );
          return;
        }

        term.write(`\r\nRefreshing PCAP for team ${teamId}...\r\n`);

        try {
          const response = await fetch(
            `/api/captures/${teamId}/${token}?t=${new Date().getTime()}`,
          );
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(
              `Server responded with status ${response.status}: ${errorText}`,
            );
          }
          const pcapBlob = await response.blob();

          if (pcapBlobUrl) {
            URL.revokeObjectURL(pcapBlobUrl);
          }

          pcapBlobUrl = URL.createObjectURL(pcapBlob);
          pcapElement.setAttribute('src', pcapBlobUrl);

          term.write('SUCCESS: PCAP data refreshed.\r\n');
        } catch (error) {
          term.write(
            `\r\nERROR: Failed to refresh PCAP file. ${error.message}\r\n`,
          );
        }
      }

      document
        .getElementById('view-pcap-btn')
        .addEventListener('click', async () => {
          const teamId = document.getElementById('teamId').value;
          const token = document.getElementById('jwt-token').value;
          await fetchPcapData(teamId, token);
          pcapOverlay.style.display = 'flex';

          if (!pcapRefreshInterval) {
            pcapRefreshInterval = setInterval(() => {
              if (!pausePcapRefreshCheckbox.checked) {
                fetchPcapData(teamId, token);
              }
            }, 5000);
          }
        });

      // --- PLAYER TAB EVENT LISTENERS ---
      document
        .getElementById('player-connect-btn')
        .addEventListener('click', () => {
          if (ws && ws.readyState !== WebSocket.CLOSED) {
            ws.close();
          }
          term.reset();

          const teamId = document.getElementById('player-team-id').value;
          const userId = document.getElementById('player-user-id').value;
          const token = document.getElementById('player-jwt-token').value;

          if (!teamId || !userId || !token) {
            term.write(
              'Please provide a Team ID, User ID, and JWT to connect.\r\n',
            );
            return;
          }

          const socketUrl = `ws://${window.location.host}/terminals/${teamId}/${userId}/${token}`;
          term.write(`Connecting to ${socketUrl}...\r\n`);

          ws = new WebSocket(socketUrl);

          ws.onopen = () => {
            term.write('Connection established! You have a shell.\r\n');
            term.focus();
          };
          ws.onmessage = async event => {
            const data =
              event.data instanceof Blob
                ? new Uint8Array(await event.data.arrayBuffer())
                : event.data;
            term.write(data);
          };
          ws.onclose = event => {
            term.write(`\r\nConnection closed. Code: ${event.code}\r\n`);
          };
          ws.onerror = error => {
            term.write('\r\nAn error occurred with the WebSocket.\r\n');
            console.error('WebSocket Error:', error);
          };
        });

      document
        .getElementById('player-get-config-btn')
        .addEventListener('click', async () => {
          const sessionId = document.getElementById('player-session-id').value;
          const teamId = document.getElementById('player-team-id').value;
          const userId = document.getElementById('player-user-id').value;
          const token = document.getElementById('player-jwt-token').value;

          if (!sessionId || !teamId || !userId || !token) {
            term.write(
              '\r\nERROR: Session, Team, User, and JWT must be provided.\r\n',
            );
            return;
          }

          term.write(`\r\nFetching config for user ${userId}...\r\n`);

          try {
            const response = await fetch(
              `/api/config/${sessionId}/${teamId}/${userId}/${token}`,
            );
            if (!response.ok) {
              throw new Error(
                `Server responded with status: ${response.status}`,
              );
            }
            const data = await response.json();

            if (data.config && data.qrCode && data.username && data.ipAddress) {
              document.getElementById('config-text').textContent = data.config;
              document.getElementById('config-qr-code').src =
                `data:image/png;base64,${data.qrCode}`;
              const tutorial = `# Install wireguard if you haven't already
sudo wg-quick up ~/Downloads/wg1.conf
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${data.username}@${data.ipAddress}`;
              document.getElementById('tutorial-text').textContent = tutorial;
              configOverlay.style.display = 'flex';
            } else {
              term.write('\r\nERROR: Incomplete config data received.\r\n');
            }
          } catch (error) {
            term.write(
              `\r\nERROR: Failed to fetch config. ${error.message}\r\n`,
            );
          }
        });

      document
        .getElementById('player-view-pcap-btn')
        .addEventListener('click', async () => {
          const teamId = document.getElementById('player-team-id').value;
          const token = document.getElementById('player-jwt-token').value;
          await fetchPcapData(teamId, token);
          pcapOverlay.style.display = 'flex';

          if (!pcapRefreshInterval) {
            pcapRefreshInterval = setInterval(() => {
              if (!pausePcapRefreshCheckbox.checked) {
                fetchPcapData(teamId, token);
              }
            }, 5000);
          }
        });

      // --- COMMON AND CLEANUP LOGIC ---
      document
        .getElementById('close-config-overlay-btn')
        .addEventListener('click', () => {
          configOverlay.style.display = 'none';
        });

      configOverlay.addEventListener('click', event => {
        if (event.target === configOverlay) {
          configOverlay.style.display = 'none';
        }
      });

      document
        .getElementById('download-config-btn')
        .addEventListener('click', () => {
          const configText = document.getElementById('config-text').textContent;
          const blob = new Blob([configText], {type: 'text/plain'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'wg1.conf';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        });

      document
        .getElementById('refresh-pcap-btn')
        .addEventListener('click', () => {
          const activeTab = document
            .querySelector('.tab-button.active')
            .textContent.trim();
          let teamId, token;
          if (activeTab === 'Admin') {
            teamId = document.getElementById('teamId').value;
            token = document.getElementById('jwt-token').value;
          } else {
            teamId = document.getElementById('player-team-id').value;
            token = document.getElementById('player-jwt-token').value;
          }
          fetchPcapData(teamId, token);
        });

      document
        .getElementById('close-pcap-overlay-btn')
        .addEventListener('click', () => {
          pcapOverlay.style.display = 'none';
          if (pcapRefreshInterval) {
            clearInterval(pcapRefreshInterval);
            pcapRefreshInterval = null;
          }
        });

      pcapOverlay.addEventListener('click', event => {
        if (event.target === pcapOverlay) {
          pcapOverlay.style.display = 'none';
          if (pcapRefreshInterval) {
            clearInterval(pcapRefreshInterval);
            pcapRefreshInterval = null;
          }
        }
      });

      document
        .getElementById('cleanup-session-btn')
        .addEventListener('click', async () => {
          const sessionId = document.getElementById('session-id').value;
          const token = document.getElementById('admin-jwt').value;

          if (!sessionId || !token) {
            term.write(
              '\r\nERROR: Session ID and Admin JWT are required for cleanup.\r\n',
            );
            return;
          }

          const isConfirmed = confirm(
            `Are you sure you want to permanently delete session ${sessionId}? This action cannot be undone.`,
          );

          if (!isConfirmed) {
            term.write('\r\nSession cleanup cancelled by user.\r\n');
            return;
          }

          term.write(`\r\nAttempting to clean up session: ${sessionId}...\r\n`);

          try {
            const response = await fetch(`/api/cleanup/${sessionId}/${token}`);
            const responseText = await response.text();

            if (response.ok) {
              term.write(`SUCCESS: ${responseText}\r\n`);
              document.getElementById('session-id').value = '';
              document.getElementById('team-id-list').innerHTML = '';
              document.getElementById('session-info').style.display = 'none';
              document.getElementById('teamId').innerHTML =
                '<option>-- Start a session first --</option>';
              document.getElementById('userId').innerHTML =
                '<option>-- Select a team first --</option>';
              document.getElementById('get-config-btn').style.display = 'none';
              document.getElementById('view-pcap-btn').style.display = 'none';
              document.getElementById('cleanup-session-btn').style.display =
                'none';
              createdTeamIds = [];
              sessionTeams = [];
              if (ws && ws.readyState !== WebSocket.CLOSED) {
                ws.close();
                term.reset();
                term.write(
                  'Welcome! Use the controls above to manage sessions.\r\n',
                );
              }
            } else {
              term.write(
                `\r\nERROR: Failed to clean up session (Status: ${response.status}). Server says: ${responseText}\r\n`,
              );
            }
          } catch (error) {
            term.write(
              `\r\nERROR: A network error occurred during cleanup: ${error.message}\r\n`,
            );
          }
        });

      // --- HEALTH CHECK LOGIC ---
      const healthIndicator = document.getElementById(
        'health-status-indicator',
      );
      const healthTooltip = document.getElementById('health-tooltip');

      async function checkHealth() {
        const token = document.getElementById('admin-jwt').value;
        try {
          const response = await fetch(`/api/health/${token}`);

          if (!response.ok) {
            throw new Error(`Status ${response.status}`);
          }

          healthIndicator.className = 'healthy';
          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            const data = await response.json();
            let tooltipText = `Status: ${data.status}\n`;
            if (data.docker) {
              tooltipText += `Docker: ${data.docker.status}\n`;
              tooltipText += `  Version: ${data.docker.serverVersion}\n`;
              tooltipText += `  CPU Cores: ${data.docker.cpuCores}\n`;
              tooltipText += `  Memory: ${(
                data.docker.memTotal /
                1024 /
                1024 /
                1024
              ).toFixed(2)} GB\n`;
              tooltipText += `  Images: ${data.docker.images}\n`;
              tooltipText += `  Containers: ${data.docker.containers} total\n`;
              tooltipText += `    - Running: ${data.docker.containersRunning}\n`;
              tooltipText += `    - Paused:  ${data.docker.containersPaused}\n`;
              tooltipText += `    - Stopped: ${data.docker.containersStopped}\n`;
            }
            if (data.subnetsRemaining !== undefined) {
              tooltipText += `Subnets Free: ${data.subnetsRemaining}\n`;
            }
            if (data.wgPortsRemaining !== undefined) {
              tooltipText += `WG Ports Free: ${data.wgPortsRemaining}`;
            }
            healthTooltip.textContent = tooltipText.trim();
          } else {
            const text = await response.text();
            healthTooltip.textContent = `Status: ${text}`;
          }
        } catch (error) {
          healthIndicator.className = 'unhealthy';
          healthTooltip.textContent = `Error: Server is unreachable.\n(${error.message})`;
        }
      }

      // Initial check and set interval
      checkHealth();
      setInterval(checkHealth, 5000);
    </script>
  </body>
</html>
